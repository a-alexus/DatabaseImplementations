<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<title>COMP9315 21T1 - Assignment 2</title>
<link rel="stylesheet" type="text/css" href="COMP9315%2021T1%20-%20Assignment%202_files/course.css"></head>
<body>
<div align="center">
<table width="100%" border="0">
<tbody><tr valign="top">
<td width="25%" align="left">
  <span class="tiny"><a href="https://cgi.cse.unsw.edu.au/~cs9315/21T1/index.php">COMP9315 21T1</a></span>
</td>
<td width="50%" align="center">
  <span class="heading">Assignment 2</span><br><b>Signature Indexes</b>
</td>
<td width="25%" align="right">
  <span class="tiny"><a href="https://cgi.cse.unsw.edu.au/~cs9315/21T1/index.php">DBMS Implementation</a></span>
</td>
</tr></tbody></table>
</div><div style="text-align:center;font-size:80%;color:#555555;margin-top:5px;">
Last updated: <strong>Tuesday 13th April 7:35am</strong> <br>
Most recent changes are shown in <span class="red">red</span>; <br>
older changes are shown in <span class="brown">brown</span>.
</div>
<div style="text-align:center;color:#CC0000;font-size:9pt;">
A changelog is at the end of the file.<br>
Hopefully, this changelog will be very short.
</div>

<nav style="text-align:center;font-size:10pt;">
    <ul>
        <li><a href="#summary">summary</a></li>
        <li><a href="#intro">introduction</a></li>
        <li><a href="#commands">commands</a></li>
        <li><a href="#data-types">data-types</a></li>
        <li><a href="#tasks">tasks</a></li>
        <li><a href="#testing">testing</a></li>
        <li><a href="#submission">submission</a></li>
        <li><a href="#changelog">changelog</a></li>
	</ul>
</nav>


<h2>Aims</h2>
<p>
This assignment aims to give you an understanding of
</p>
<ul>
<li> how database files are structured and accessed
</li><li> how <b>s</b>uper<b>im</b>posed <b>c</b>odeword (SIMC) signatures are implemented
</li><li> how con<b>cat</b>enated <b>c</b>odeword (CATC) signatures are implemented
</li><li> how partial-match retrieval searching is implemented using signatures
</li><li> the performance differences between different types of signatures 
</li></ul>
<p>
The goal is to build a simple implementation of a signature indexed file,
including applications to create such files, insert tuples into them,
and search for tuples based on partial-match retrieval queries.
</p>


<h2 id="summary">Summary</h2>
<table cellpadding="6">
<tbody><tr>
<td><b>Deadline</b>:</td>
<td>11:00am on <b>Monday 19 April</b></td>
</tr>
<tr>
<td><b>Late Penalty</b>:</td>
<td>0.125 <em>marks</em> off the ceiling mark for each hour late (i.e. 3 marks/day)</td>
</tr>
<tr>
<td><b>Marks:</b></td>
<td>contributes <b>20 marks</b> toward your total mark for this course.
</td></tr>
<tr>
<td><b>Groups:</b></td>
<td> you must complete this assignment individually</td>
</tr>
<tr>
<td><b>Submission</b>:</td>
<td> login to Course Web Site
&gt; Assignments &gt; Assignment 2 &gt; Submission
&gt; upload &nbsp;<tt>ass2.tar</tt><br>
or login to any CSE server &gt; <tt>give cs9315 ass2 ass2.tar</tt> </td>
</tr>
<tr>
<td><b>Workspace:</b></td>
<td>any machine wth a C compiler (preferably <tt>gcc</tt>); 
you do <em>not</em> need to use Grieg</td>
</tr>
</tbody></table>
<p>
The <tt>ass2.tar</tt> file must contain the <tt>Makefile</tt> plus
all of the <tt>*.c</tt> and <tt>*.h</tt> files that are needed to
compile the <tt>create</tt>, <tt>insert</tt> and <tt>select</tt>
executables.
</p>
<p>
You are <em>not</em> allowed to change the following files:
<tt>create.c</tt>, <tt>insert.c</tt>, <tt>select.c</tt>,
<tt>stats.c</tt>, <tt>dump.c</tt>, <tt>hash.h</tt>, <tt>hash.c</tt>,
<tt>x1.c</tt>, <tt>x2.c</tt>, <tt>x3.c</tt>.
We supply them when we/you test your files, so any changes you
make will be overwritten.
Do not include them in the <tt>ass2.tar</tt> file.
Details on how to build the <tt>ass2.tar</tt> file are given below.
</p>
<p>
Note that the code in <tt>create.c</tt>, <tt>insert.c</tt>, <tt>select.c</tt>,
<tt>stats.c</tt>, <tt>dump.c</tt> assumes that you honour the
interfaces to the ADTs defined in the <tt>*.[ch]</tt> file pairs.
If you change the interfaces to data types like <tt>bits.h</tt>
and <tt>page.h</tt>, then your program will be treated as incorrect.
</p><p>
Make sure that you read this assignment specification <em>carefully and
completely</em> before starting work on the assignment.<br>
Questions which indicate that you haven't done this will simply get the
response "Please read the spec".
</p>
<p>
<b>Note:</b> this assignment <em>does not</em> require you to do anything with PostgreSQL.
</p>

<h2 id="intro">Introduction</h2>
<p>
Signatures are a style of indexing where (in its simplest form)
each tuple is associated with a compact representation of its values
(i.e. its <i>signature</i>).
Signatures are used in the context of partial-match retrieval queries,
and are particularly effective for large tuples.
Selection is performed by first forming a <i>query signature</i>, based on
the values of the known attributes, and then scanning the stored signatures,
matching them against the query signature, to identify potentially
matching tuples.
Only these tuples are read from the data pages and compared against
the query to check whether they are true matching tuples.
Signature matching can result in "false matches",
where the query and tuple signatures match,
but the tuple is not a valid result for the query.
Note that signature matching can be quite efficient if the signatures
are small, and efficient bit-wise operations are used to check for
signature matches.
</p>
<p>
The kind of signature matching described above uses one signature
for each tuple (as in the diagram below). Other kinds of signatures
exist, and one goal is to implement them and compare their performance
to that of tuple signatures.
</p>
<center><img src="COMP9315%2021T1%20-%20Assignment%202_files/tsig-matching.png"></center>
<p>
In files such as the above, queries are evaluated as follows:
</p>
<pre><span class="comment">Input: pmr query, Output: set of tuples satisfying the query</span>
qrySig = makeSignature(query)
Pages = {}  <span class="comment">// set of pages containing possibly matching tuples</span>
foreach tupSig in SignatureFile {
    if (tupSig matches qrySig) {
        <span class="comment">// potential match</span>
       PID = page of tuple associated with tupSig
       add PID to Pages
    }
}
Results = {}  <span class="comment">// set of tuples satisfying query</span>
foreach PID in Pages {
    buf = fetch data page PID
    foreach tuple in buf {
        <span class="comment">// check for real match</span>
        if (tuple satisfies query) add tuple to Results
    }
}
</pre>
<p>
Note that above algorithm is an abstract view of what you must implement
in your code. The function <tt>makeSignature()</tt> does not literally
exist, but you need to build analogues to it in your code.
</p>
<h4>Signatures</h4>
<p>
We will consider two methods for building signatures:
<b>s</b>uper<b>im</b>posed <b>c</b>odewords (SIMC),
and con<b>cat</b>enated <b>c</b>odewords (CATC).
Each codeword is formed using the value from one attribute.
</p>
<center><img src="COMP9315%2021T1%20-%20Assignment%202_files/make-sig.png"></center>
<p>
In SIMC signatures, all codewords and signatures are <i>m</i> bits wide,
and each codeword has <i>k</i> bits set to 1.
In CATC signatures, signatures are <i>m</i> bits wide, but codewords
occupy approximately equal numbers of bits of the signature.
Since there are <i>m</i> bits in the signature and <i>n</i> attributes,
each codeword is <i>u = m/n</i> bits long, except for the lower-order
codeword (the one for the first attribute). This codeword is <i>u</i>
bits long + <i>m mod n</i> bits, so that the total number of codeword
bits is equal to <i>m</i>. The following diagram shows the parts of 
a concenated codeword signature:
</p>
<center><img src="COMP9315%2021T1%20-%20Assignment%202_files/catc-sig.png"></center>
<p>
In this example, the signature is <i>m</i>=42 bits wide.
Each codeword, except the lower-order one, is <i>u</i>=10 bits wide.
The lower-order codeword has two extra bits to make up to 42.
Each codeword has half of its bits set to 1; in CATC codewords,
<i>k</i> = u/2. This is different to SIMC codewords, where
we need to determine <i>k</i> to ensure that roughly half of the
bits in the signature are set to 1.
</p>
<p>
The way we build CATC signatures is conceptually straightforward:
form <i>n</i> codewords, each of which is <i>m/n</i> bits wide,
and concatenate them.
In practice, we build <i>n</i> codewords, each of which is <i>m</i>
bits wide, with the lower-order <i>u</i> bits set as the codeword,
and then, shifted into the position that it would occupy in a concatenated
codeword signature. The diagram below illustrates this:
</p>
<center><img src="COMP9315%2021T1%20-%20Assignment%202_files/make-catc-sig.png"></center>
<p>
Note: the fact individual codewords are 8-bits long is not intended
to suggest that codewords will always be whole bytes.
Individual codewords would be 6-bits if <i>m</i> = 24,
or 9-bits if <i>m</i> = 36.
And, as noted above, if <i>m</i> = 42, the codeword
for attribute 1 would be 12-bits and all other attributes would have
10-bit codewords.
</p>
<p>
In subsequent discussions, we denote the length of tuple signatures as
<i>m</i>, the length of page signatures as <i>m<sub>p</sub></i>, and the
length of CATC codewords as <i>u</i> (remembering that all SIMC codewords
have the same length as the signatures they produce).
</p>
<h4>Relations</h4>
<p>
In our system, a relation <tt>R</tt> is represented by five physical files:
</p>
<ul>
<li><p>
<tt>R.info</tt> containing global information such as
</p><ul>
<li> the number of attributes and size of each tuple
</li><li> the number of data pages and number of tuples
</li><li> the base type of signatures (<tt>simc</tt> or <tt>catc</tt>)
</li><li> the sizes of the various kinds of signatures
</li><li> the number of signatures and signature pages
</li><li> etc. etc. etc.
</li></ul>
<p>
The <tt>R.info</tt> file contains a copy of the <tt>RelnParams</tt>
structure given in the <tt>reln.h</tt> file (see below).
</p>
</li>
<li><p>
<tt>R.data</tt> containing data pages, where each data page contains
</p><ul>
<li> a count of the number of tuples in the page
</li><li> the tuples (as comma-separated character sequences)
</li></ul>
<p>
Each data page has a capacity of <i>c</i> tuples. If there are
<i>n</i> tuples then there will be <i>b</i> = ⌈<i>n/c</i>⌉
pages in the data file. All pages except the last are full.
Tuples are never deleted.
</p></li>
<li><p>
<tt>R.tsig</tt> containing tuple signatures, where each page contains
</p><ul>
<li> a count of the number of signatures in the page
</li><li> the signatures themselves (as bit strings)
</li></ul>
<p>
Each tuple signature is formed by incorporating the codewords
from each attribute in the tuple.
How this is done differs between SIMC and CATC, but the
overall result is a single <i>m</i>-bit long signature.
If there are <i>n</i> tuples
in the relation, there will be <i>n</i> tuple signatures, in
<i>b<sub>t</sub></i> pages. All tuple signature pages except
the last are full.
</p></li>
<li><p>
<tt>R.psig</tt> containing page signatures, where each page contains
</p><ul>
<li> a count of the number of signatures in the page
</li><li> the signatures themselves (as bit strings)
</li></ul>
<p>
Page signatures are much larger than tuple signatures,
and are formed by incorporating the codewords of all
attribute values in all tuples in the page.
How this is done differs between SIMC and CATC, but the
result is a single <i>m<sub>p</sub></i>-bit long signature
There is one page signature for each page in the data file.
</p></li>
<li><p>
<tt>R.bsig</tt> containing bit-sliced signatures, where each page contains
</p><ul>
<li> a count of the number of signatures in the page
</li><li> the bit-slices themselves (as bit strings)
</li></ul>
<p>
Bit-slices give an alternate 90<sup>o</sup>-rotated view of page signatures.
If there are <i>b</i> data pages, then each bit-slice is <i>b</i>-bits long.
If page signatures are <i>pm</i> bits long, then there are <i>pm</i> bit-slices.
</p></li>
</ul>
<p>
The following diagram gives a very simple example of the correspondence
between page signatures and bit-slices:
</p>
<center><img src="COMP9315%2021T1%20-%20Assignment%202_files/psig-bsig.png"></center>
<h4>Pages</h4>
<p>
The different types of pages (tuple, signature, slice)
were described above.
Internally, all pages have a similar structure: a counter holding the number of
items in the page, and the items themselves (tuples or signatures or slices).
All of the items in a page are the same size.
The following diagram shows the structure of
pages in the files of a signature-indexed relation:
</p>
<center><img src="COMP9315%2021T1%20-%20Assignment%202_files/simc-pages.png"></center>
<p>
We have developed some infrastructure for you to use in implementing
these signatur-indexed files.
The code we give you is not complete; you can find the bits that need
to be completed by searching for <tt>TODO</tt> in the code.
</p>
<p>
How you implement the missing parts of the code is up to you,
but your implementation must conform to the conventions used in our code.
In particular, you should preserve the interfaces to the supplied modules
(e.g. <tt>Bits</tt>, <tt>Reln</tt>, <tt>Query</tt>, <tt>Tuple</tt>)
and ensure that your submitted modules work with the supplied code
in the <tt>create</tt>, <tt>insert</tt> and <tt>select</tt> commands.
</p>

<h2 id="commands">Commands</h2>
<p>
In our context, signature-indexed relations are a collection of files
that represent one relational table. These relations can be
manipulated by a number of supplied commands:
</p>
<dl>
<dt> <tt><big><b>create</b></big> RelName  SigType  #tuples  #attrs  1/pF</tt>
</dt><dd>
<p>
Creates an empty relation called <i>RelName</i> with all tuples
having <i>#attrs</i> attributes.
<i>SigType</i> specifies how signatures should be formed,
and can have one of two values: <tt>simc</tt> or <tt>catc</tt>.
The <i>#tuples</i> parameter gives the expected number of tuples
that are likely to be inserted into a relation; this, in turn,
determines parameters like the number of data pages and length
of bit-sliced superimposed codewords.
The <i>1/pF</i> parameter gives the inverse of the false match probability;
for example, a value of 1000 corresponds to a false match probability of
1/1000 (0.001).
</p>
<p>
These parameters are combined using the formulas given in lectures
to determine how large tuple- and page-signatures are.
Each bit-slice has a number of bits equal to the number of data pages,
which is determined from <i>#attrs</i>, <i>#tuples</i> and the page size.
</p>
<p>
This gives you storage for one relation/table,
and is analogous to making an SQL data definition like:
</p>
<pre>create table R ( a<sub>1</sub> integer, a<sub>2</sub> text, ... a<sub>n</sub> text );
</pre>
<p>
Note that internally, attributes are indexed 0..<i>n</i>-1 rather
than 1..<i>n</i>.
</p>
<p>
The following example of using <tt>create</tt> makes a relation called <tt>abc</tt>
where each tuple has 4 attributes and the indexing has a false match probability
of 1/100. The relation can hold up to 10000 tuples (it can actually hold more,
but only the first 10000 will be indexed via the bit-sliced signatures).
</p>
<pre>$ <b>./create  abc  simc  10000  4  100</b>
</pre>
<p></p>
</dd>
<dt> <tt><big><b>insert</b></big> RelName</tt> </dt>
<dd>
<p>
Reads tuples, one per line, from standard input
and inserts them into the relation specified on the command line.
Tuples all take the form <i>val<sub>1</sub>,val<sub>2</sub>,...,val<sub>n</sub></i>.
The values can be any sequence of alpha-numeric characters and <tt>'-'</tt>.
The characters <tt>','</tt> (field separator) and <tt>'?'</tt> (query wildcard)
are treated specially.
</p>
<p>
Since all tuples need to be the same length, it is simplest to use
<tt>gendata</tt> to generate them, and pipe the generated tuples
into the <tt>insert</tt> command
</p>
</dd>
<dt> <tt><big><b>select</b></big> RelName QueryString IndexType</tt> </dt>
<dd>
<p></p>
Takes a "query tuple" on the command line, and finds all tuples in
the data pages of the relation <i>RelName</i> that match the query.
<i>IndexType</i> has a value of either <tt>t</tt>, <tt>p</tt> or
<tt>b</tt>, indicating whether it should used the <b>t</b>uple, <b>p</b>age,
or <b>b</b>it-sliced signatures.
Queries take the form <i>val<sub>1</sub>,val<sub>2</sub>,...,val<sub>n</sub></i>,
where some of the <i>val<sub>i</sub></i> can be <tt>'?'</tt> (without the quotes).
Some examples, and their interpretation are given below. You can find more
examples in the lecture slides and course notes.
<p></p>
<pre>?,?,?    <span class="comment"># matches any tuple in the relation</span>
10,?,?   <span class="comment"># matches any tuple with 10 as the value of attribute 1</span>
?,abc,?  <span class="comment"># matches any tuple with abc as the value of attribute 2</span>
10,abc,? <span class="comment"># matches any tuple with 10 and abc as the values of attributes 1 and 2</span>
</pre>
</dd>
</dl>

<br>
<p>
There are also a number of auxiliary commands to assist with building
and examining relations:
</p>
<dl>
<dt> <tt><big><b>gendata</b></big>  #tuples  #attributes  [startID]  [seed]</tt> </dt>
<dd>
<p>
Generates a specified number of <i>n</i>-attribute tuples in the
appropriate format to insert into a created relation.
All tuples are the same format and look like
</p>
<pre><i>UniqID</i>,<i>RandomString</i>,a3-<i>Num</i>,a4-<i>Num</i>,...,a<sub>n</sub>-<i>Num</i>
</pre>
<p>
For example, the following 4-attribute tuples could be generated by a call
like &nbsp; <nobr><tt>gendata 1000 4</tt></nobr>
</p>
<pre>7654321,aTwentyCharLongStrng,a3-013,a4-001
3456789,aTwentyChrLongString,a3-042,a4-128
</pre>
<p>
Of course, the above call to <tt>gendata</tt> will generate 1000 tuples like these.
</p>
<p>
A tuple is represented by a sequence of comma-separated fields. The first field is
a unique 7-digit number; the second field is a random 20-char string
(most likely unique in a given database);
the remaining fields have a field identifier followed by a non-unique
3-digit number.
The size of each tuple is
</p><pre>7+1 + 20+1 + (<i>n</i>-2)*(6+1)-1  = 28 + 7*(n-2) bytes
</pre>
<p>
The <tt>-1</tt> is because the last attribute doesn't have a trailing
comma, and <tt>(<i>n</i>-2)*(6+1)</tt> assumes that it does.
</p>
<p>
Note that tuples are limited to at most 9 attributes, which means
that the maximum tuple size is a modest 77 bytes.
(If you wish, you can work with larger tuples by tweaking the
<tt>gendata</tt> and <tt>create</tt> commands and the
<tt>newRelation()</tt> function, but this not required
for the assignment).
</p>
</dd>
<dt> <tt><big><b>stats</b></big> RelName</tt> </dt>
<dd><p>
Prints information about the sizes of various aspects of the relation.
Note that some aspects are static (e.g. the size of tuples) and some
aspects are dynamic (e.g. the number of tuples). An example of using
the <tt>stats</tt> command is given below.
</p><p>
You can use it to help with debugging, by making sure that the
files have been correctly built after the <tt>create</tt> command,
and that the files have been correctly updated after some tuples
have been <tt>insert</tt>ed.
</p></dd>
<dt> <tt><big><b>dump</b></big> RelName</tt> </dt>
<dd>
<p>
Writes all tuples from the relation <i>RelName</i>,
one per line, to standard output.
This is like an inverse of the <tt>insert</tt> command.
Tuples are dumped in a form that could be used by <tt>insert</tt> to
rebuild a database.
</p>
<p>
You can use it to help with debugging, by making sure that the
tuples are inserted correctly into the data file.
</p>
</dd>
</dl>

<h2 id="setting-up">Setting Up</h2>
<p>
You should make a working directory for this assignment and put
the supplied code there, and start reading to make sure that you
understand all of the data types and operations used in the
system.
</p>
<pre>$ <b>mkdir <i>your/ass2/directory</i></b>
$ <b>cd <i>your/ass2/directory</i></b>
$ <b>unzip <a href="https://cgi.cse.unsw.edu.au/~cs9315/21T1/assignments/ass2/ass2.zip">/web/cs9315/21T1/assignments/ass2/ass2.zip</a></b>
</pre>
<p>
You should see the following files in the directory:
</p>
<pre>$ <b>ls</b>
Makefile	dump.c		psig.c		stats.c		x1.c
bits.c		gendata.c	psig.h		tsig.c		x2.c
bits.h		hash.c		query.c		tsig.h		x3.c
bsig.c		hash.h		query.h		tuple.c
bsig.h		insert.c	reln.c		tuple.h
create.c	page.c		reln.h		util.c
defs.h		page.h		select.c	util.h
</pre>
<p>
The <tt>.h</tt> files define data types and function interfaces
for the various types used in the system.
The corresponding <tt>.c</tt> files contain the implementation
of the functions on the data type.
The  remaining <tt>.c</tt> files either provide the commands
described above, or are test harnesses for individual types
(<tt>x1.c</tt>, <tt>x2.c</tt>, <tt>x3.c</tt>).
You can add additional testing files, bu there is no need to
submit them.
</p>
<p>
The above files give you a partial implementation of signature-based
indexing. You need to complete the code so that it provides
the functionality described above.
</p>
<p>
You should be able to build the supplied partial
implementation via the following:
</p>
<pre>$ <b>make</b>
gcc -std=gnu99 -Wall -Werror -g   -c -o query.o query.c
gcc -std=gnu99 -Wall -Werror -g   -c -o page.o page.c
gcc -std=gnu99 -Wall -Werror -g   -c -o reln.o reln.c
gcc -std=gnu99 -Wall -Werror -g   -c -o tuple.o tuple.c
gcc -std=gnu99 -Wall -Werror -g   -c -o util.o util.c
gcc -std=gnu99 -Wall -Werror -g   -c -o tsig.o tsig.c
gcc -std=gnu99 -Wall -Werror -g   -c -o psig.o psig.c
gcc -std=gnu99 -Wall -Werror -g   -c -o bsig.o bsig.c
gcc -std=gnu99 -Wall -Werror -g   -c -o hash.o hash.c
gcc -std=gnu99 -Wall -Werror -g   -c -o bits.o bits.c
gcc -std=gnu99 -Wall -Werror -g   -c -o create.o create.c
gcc -o create create.o query.o page.o reln.o tuple.o util.o tsig.o psig.o bsig.o hash.o bits.o -lm
gcc -std=gnu99 -Wall -Werror -g   -c -o insert.o insert.c
gcc   insert.o query.o page.o reln.o tuple.o util.o tsig.o psig.o bsig.o hash.o bits.o   -o insert
gcc -std=gnu99 -Wall -Werror -g   -c -o select.o select.c
gcc   select.o query.o page.o reln.o tuple.o util.o tsig.o psig.o bsig.o hash.o bits.o   -o select
gcc -std=gnu99 -Wall -Werror -g   -c -o stats.o stats.c
gcc   stats.o query.o page.o reln.o tuple.o util.o tsig.o psig.o bsig.o hash.o bits.o   -o stats
gcc -std=gnu99 -Wall -Werror -g   -c -o gendata.o gendata.c
gcc -o gendata gendata.o util.o -lm
gcc -std=gnu99 -Wall -Werror -g   -c -o dump.o dump.c
gcc   dump.o query.o page.o reln.o tuple.o util.o tsig.o psig.o bsig.o hash.o bits.o   -o dump
gcc -std=gnu99 -Wall -Werror -g   -c -o x1.o x1.c
gcc -o x1 x1.o query.o page.o reln.o tuple.o util.o tsig.o psig.o bsig.o hash.o bits.o
gcc -std=gnu99 -Wall -Werror -g   -c -o x2.o x2.c
gcc -o x2 x2.o query.o page.o reln.o tuple.o util.o tsig.o psig.o bsig.o hash.o bits.o
gcc -std=gnu99 -Wall -Werror -g   -c -o x3.o x3.c
gcc -o x3 x3.o query.o page.o reln.o tuple.o util.o tsig.o psig.o bsig.o hash.o bits.o
</pre>
<p>
This should not produce any errors on the CSE servers; let me know ASAP
if this is not the case.
</p>
<p>
The <tt>gendata</tt> command should work completely without change.
For example, the following command generates 5 tuples, each of which
has 4 attributes.
Values in the first attribute are unique; values in the second
attribute are highly likely to be unique.
Note that the third and fourth attributes cycle
through values at different rates, so they won't always have the
same number.
</p>
<pre>$ <b>./gendata 5 4</b>
1000000,lrfkQyuQFjKXyQVNRTyS,a3-000,a4-000 -&gt; 0
1000001,FrzrmzlYGFvEulQfpDBH,a3-001,a4-001 -&gt; 0
1000002,lqDqrrCRwDnXeuOQqekl,a3-002,a4-002 -&gt; 0
1000003,AITGDPHCSPIjtHbsFyfv,a3-003,a4-003 -&gt; 0
1000004,lADzPBfudkKlrwqAOzMi,a3-004,a4-004 -&gt; 0
</pre>
<p>
The <tt>create</tt> command itself is complete, but some of the
functions it calls are not complete. It will allow you to make an
empty relation, although without a complete bit-slice file (you add
this as one of the assignment tasks).
The <tt>stats</tt> command is complete and can display information
about a relation.
Using these commands, you could do the following: use the <tt>create</tt>
command to create an empty relation which can hold 4-attribute tuples
and able to index up to 5000 tuples (using bit-slices), with a false match
probability of 1/1000. The <tt>stats</tt> command then displays
the generated parameter values.
</p>
<pre>$ <b>./create R simc 5000 4 1000</b>
$ <b>./stats R</b>
Global Info:
Dynamic:
  #items:  tuples: 0  tsigs: 0  psigs: 0  bsigs: 0
  #pages:  tuples: 1  tsigs: 1  psigs: 1  bsigs: 1
Static:
  tups   #attrs: 4  size: 42 bytes  max/page: 97
  sigs   simc  bits/attr: 9
  tsigs  size: 64 bits (8 bytes)  max/page: 511
  psigs  size: 5584 bits (698 bytes)  max/page: 5
  bsigs  size: 56 bits (7 bytes)  max/page: 584
$
</pre>
<p>
You can apply the formulae for calculating the various
quantities to check that the above values make sense.
Note that the bits for signatures are rounded up to
the next multiple of 8 (why waste a few bits?).
Note also that all pages are defined to be 4096 bytes.
Finally, note that <tt>create</tt> makes a file
with one empty page for each of the files holding tuples
and signatures.
</p>
<p>
As supplied, the <tt>insert</tt> command inserts tuples into the data
pages, but does not generate any signatures.
Using <tt>gendata</tt> is the easiest (and safest) way to add
valid tuples.
You can then check that the tuples have been inserted via the
<tt>dump</tt> command, and see how the parameters have changed using
<tt>stats</tt> again.
</p>
<pre>$ <b>./gendata 5 4 | ./insert -v R</b>
Inserting: 1000000,lrfkQyuQFjKXyQVNRTyS,a3-000,a4-000
Inserting: 1000001,FrzrmzlYGFvEulQfpDBH,a3-001,a4-001
Inserting: 1000002,lqDqrrCRwDnXeuOQqekl,a3-002,a4-002
Inserting: 1000003,AITGDPHCSPIjtHbsFyfv,a3-003,a4-003
Inserting: 1000004,lADzPBfudkKlrwqAOzMi,a3-004,a4-004
$ <b>./stats R</b>
Global Info:
Dynamic:
  #items:  tuples: <span class="red">5</span>  tsigs: 0  psigs: 0  bsigs: 0
  #pages:  tuples: 1  tsigs: 1  psigs: 1  bsigs: 1
Static:
  tups   #attrs: 4  size: 42 bytes  max/page: 97
  sigs   simc  bits/attr: 9
  tsigs  size: 64 bits (8 bytes)  max/page: 511
  psigs  size: 5584 bits (698 bytes)  max/page: 5
  bsigs  size: 56 bits (7 bytes)  max/page: 584
$
</pre>
<p>
Note that the only difference between the above stats and the
stats for the newly-created file is the 5 tuples.
There are no signatures, no new pages, etc.
</p>
<p>
The <tt>dump</tt> command is complete; it simply scans the
data file and displays any tuples it finds, e.g.
</p>
<pre>$ <b>./dump R</b>
1000000,lrfkQyuQFjKXyQVNRTyS,a3-000,a4-000
1000001,FrzrmzlYGFvEulQfpDBH,a3-001,a4-001
1000002,lqDqrrCRwDnXeuOQqekl,a3-002,a4-002
1000003,AITGDPHCSPIjtHbsFyfv,a3-003,a4-003
1000004,lADzPBfudkKlrwqAOzMi,a3-004,a4-004
$
</pre>
<p>
The <tt>select</tt> command, as supplied, is not complete.
However, once it is working (at least with tuple signatures),
you should be able to ask queries like:
</p>
<pre>$ <b>./select  R  '1000001,?,?'  t</b>       <span class="comment"># not enough attrs</span>
Invalid query: 101,?,?
$ <b>./select  R  '1000001,?,?,?'  t</b>
1000001,FrzrmzlYGFvEulQfpDBH,a3-001,a4-001
Query Stats:
# signatures read:   5
# sig pages read:    1
# tuples examined:   5
# data pages read:   1
# false match pages: 0
$ <b>./select  R  '1000001,?,a3-002,?'  t</b>
Query Stats:
# signatures read:   5
# sig pages read:    1
# tuples examined:   0
# data pages read:   0
# false match pages: 0
$ <b>./select  R  '1000001,?,a3-002,?'  <span class="red">x</span></b>
Query Stats:
# signatures read:   0
# sig pages read:    0
# tuples examined:   5
# data pages read:   1
# false match pages: 1
</pre>
<p>
Some explanation:
</p><ul>
<li><p>
The second query finds a match because there is a tuple
with the value <tt>1000001</tt> for its first attribute.
The <tt>?</tt> represent "don't care" or wild-card values.
</p></li>
<li><p>
The third query fails because the tuple with <tt>1000001</tt>
for its first attribute, does not have the value <tt>a3-002</tt>
for its third attribute.
</p></li>
<li><p>
The fourth query performs a linear scan of the data file.
Since the query itself is the same as the third query,
there are no matching tuples.
This query reads every data page (there is only one).
Any data page read, which does not contain matching tuples,
is counted as a "<tt>false page match</tt>".
</p></li>
<li><p>
The <tt>t</tt> at the end of the query tells the query
evaluator to use tuple signatures as a first-pass filter.
Other possibilities are <tt>p</tt> for page signatures
or <tt>b</tt> for bit-sliced signatures.
If you use a character other than <tt>t</tt>, <tt>p</tt>,
or <tt>b</tt>, or don't specify a signature type, the evaluator
uses a linear scan and checks all tuples.
</p></li>
<li><p>
With all types of signatures, queries run in two phases:
</p><ul>
<li> use the signatures to determine which pages may contain matching tuples
</li><li> read each of these pages and check all tuples to find real matches
</li></ul>
<p></p></li>
<li><p>
The query statistics are maintained in a <tt>Query</tt> data
structure while the query is executing.
</p></li>
</ul>

<h2 id="data-types">Data Types</h2>
<p>
There are four important data types defined in the system:
</p>
<dl>
<dt> <b>Relations</b> (data type <tt>Reln</tt>)</dt> 
<dd><p>
Relations are defined by three data types: <tt>Reln</tt>,
<tt>RelnRep</tt>, <tt>RelnParams</tt>.
<tt>Reln</tt> is just a pointer to a <tt>RelnRep</tt> object;
this is useful for passing to functions that need to modify
some aspect of the relation structure.
<tt>RelnRep</tt> is a representation of an open relation
and contains the parameters, plus file descriptors for
all of the open files.
<tt>RelnParams</tt> is a list of various properties of
the database.
See <tt>reln.h</tt> for details.
</p></dd>
<dt> <b>Queries</b> (data type <tt>Query</tt>)</dt> 
<dd><p>
Queries are defined via a <tt>QueryRep</tt> structure
which contains fields to represent the current state
of the scan for the query, plus a collection of statistics
counters. It is essentially like the query iteration
structures described in lectures, and is used to control
and monitor the query evaluation.
The <tt>QueryRep</tt> structure also contains a reference
to the relation being queried, and a copy of the
query string.
The <tt>Query</tt> data type is simply a pointer to a
<tt>QueryRep</tt> structure.
See <tt>query.h</tt> for details.
The following diagram might also help:
</p>
<center><img src="COMP9315%2021T1%20-%20Assignment%202_files/queryrep.png"></center>
<p></p>
</dd>
<dt> <b>Pages</b> (data type <tt>Page</tt>)</dt> 
<dd><p>
Pages are defined via a <tt>PageRep</tt> structure
which contains a counter for the number of items,
and then an array of bytes containing the actual items,
whether they are tuples or signatures or slices.
The size of each type of item is held in the <tt>RelnParams</tt>
structure, and so <tt>Page</tt>s are typically considered
in conjunction with <tt>Reln</tt>s.
The <tt>Page</tt> data type is simply a pointer to a
<tt>PageRep</tt> structure.
See <tt>page.h</tt> for details.
The following diagram might also help:
</p>
<center><img src="COMP9315%2021T1%20-%20Assignment%202_files/pagerep.png"></center>
<p></p>
</dd>
<dt> <b>Bit-strings</b> (data type <tt>Bits</tt>)</dt> 
<dd><p>
Bit-strings are defined via a <tt>BitsRep</tt> structure
which contains two counters (one for the number of bits,
and the other for the number of bytes used to represent
the bit-string).
The <tt>BitsRep</tt> structure also contains an array of
bytes which hold the bits in the string; the array is
created when and instance of a <tt>Bits</tt> data type
is created.
Note that <tt>Bits</tt> is an ADT, so the concrete data
structure is hidden from its clients; the <tt>Bits</tt>
data type is simply a pointer to a <tt>BitsRep</tt> structure.
See <tt>bits.c</tt> for details of the data structure,
and <tt>bits.h</tt> for the function interface.
The following diagram might help:
</p>
<center><img src="COMP9315%2021T1%20-%20Assignment%202_files/bitsrep.png"></center>
<p></p>
</dd>
</dl>
<dt> <b>Tuple</b> (data type <tt>Tuple</tt>)</dt> 
<dd><p>
Tuples are just character sequences (like C strings).
See <tt>tuple.h</tt> for details.
</p></dd>

<p>
There are also a range of (hopefully) self-explanatory
data types defined in <tt>defs.h</tt>.
The various signature types are represented as bit-strings
(<tt>Bits</tt>).
</p>

<h2 id="tasks">Goal</h2>
<p>
Your goal for this assignment is to complete the implementation of
the various components of the system, so that it can handle all
three kinds of signatures.
This includes adding/modifying signatures when new tuples are
added, and using these signatures in answering queries.
Note that ew don't consider operations like <tt>DELETE</tt>
or <tt>UPDATE</tt> in this assignment.
</p>
<p>
The header (<tt>.h</tt>) files contain definitions of the data
types used in the system.
</p>
<p>
Each of the source code (<tt>.c</tt>)files contains comments
on each function, describing briefly what it should do.
Some functions contain <tt>TODO</tt> comments to indicate
where you need to complete them.
You can put all of the code in the indicated function, or you
can write new functions that these functions use.
</p>
<p>
You are free to change any file except <tt>create.c</tt>,
<tt>insert.c</tt>, <tt>select.c</tt> and <tt>hash.c</tt>.
Since you can't change these files, you also cannot change
the interfaces to the data types that they use (<tt>Reln</tt>,
<tt>Query</tt>, <tt>Page</tt>, <tt>Bits</tt>).
Basically, all of the functions mentioned in the <tt>.h</tt>
files for these types must exist, with the same interface,
but you can implement their internals however you like.
You can also add extra functions to each data type (i.e.
extend its interface) if that helps.
</p>
<p>
The files <tt>x1.c</tt>, <tt>x2.c</tt>, <tt>x3.c</tt> can
be changed, but aren't relevant to the assignment, except
to help with debugging some of the data types.
</p>

<h2>Task 1: A Bit-string Type
<span style="font-weight:normal; font-size:50%">(3 marks)
</span></h2>
<p>
Implement all of the incomplete functions in the <tt>bits.c</tt>
file, to produce a working bit-string data type.
The functions to complete are flagged with <tt>TODO</tt>,
and the purpose of each should be clear from the comment
at the start of the function and its name.
The <tt>x1.c</tt> file contains some simple test cases
for the <tt>Bits</tt> type.
</p>

<h2>Task 2: Scanning for Results
<span style="font-weight:normal; font-size:50%">(4 marks)
</span></h2>
<p>
After you have <tt>Bits</tt> working, you can start to
implement query evaluation, although without indexing.
The <tt>startQuery()</tt> function parses the query string
and then uses the appropriate type of signature to generate
a list of pages which potentially contain matching tuples.
This list is implemented as a bit-string where a 1 indicates
a page which needs to be checked for matches.
At this stage, all of the signature types mark all pages
as potential matches, so all pages need to be checked.
</p>
<p>
Note that the <tt>startQuery()</tt> function can return <tt>NULL</tt>.
It should do so only if the query string contains the wrong number of
attributes for the relation.
</p>
<p>
Before this will work, you need to implement the
<tt>scanAndDisplayMatchingTuples()</tt> function,
which performs the check for matching tuples
in each of the marked pages.
This function, as well as finding and displaying
result tuples, maintains the query statistics for
number of data pages read, and number of pages
that were read but contained no matching tuples.
</p>
<p>
For this task, you need to complete the
<tt>scanAndDisplayMatchingTuples()</tt> function
from the <tt>query.c</tt> file.
This function behaves roughly as follows:
</p>
<pre>foreach PID in 0 .. npages-1 {
    if (PID is not set in MatchingPages)
        ignore this page
    for each tuple T in page PID {
        if (T matches the query string)
            display it as a query result
    }
    if (no tuples in page PID are results)
        count it as a false match page
}
</pre>
<h2>Task 3: Tuple Signatures
<span style="font-weight:normal; font-size:50%">(6 marks)
</span></h2>
<p>
Implement indexing by using tuple-based signatures
(i.e. each tuple has its own signature, stored in
the <i>Rel</i><tt>.tsig</tt> file).
<span style="color:#CC0000">
Signatures could be either SIMC or CATC, as determined
from the meta-data in the <tt>*.info</tt> file.
</span>
You will need to complete the <tt>makeTupleSig()</tt>
and <tt>findPagesUsingTupSigs()</tt> functions in the
<tt>tsig.c</tt> file, and add some code to the
<tt>addToRelation()</tt> function in <tt>reln.c</tt>.
</p>
<p>
The <tt>addToRelation()</tt> function inserts a tuple
into the next available slot in the data file,
but currently does nothing with signatures.
You should add code here which generates a tuple signature
for the new tuple and inserts it in the next available slot
in the <i>Rel</i>.tsig file.
</p><p>
The <tt>makeTupleSig()</tt> function takes a tuple and returns
a bit-string which contains a tuple signature
for that tuple. It behaves roughly as follows:
</p>
<pre>Tsig = AllZeroBits
for each attribute A in tuple T {
    CW = codeword for A
    Tsig = Tsig OR CW
}
</pre>
<p>
The difference between SIMC and CATC signatures occurs in how
the codewords are computed. You will need to determine the best
point in the code to check the signature type and then how to
determine the codewords appropriately.
</p><p>
A method for computing codewords (in 32-bit bit-strings)
is given <s>in the lecture notes</s> below:
</p>
<pre>Bits codeword(char *attr_value, int m, int k)
{
   int  nbits = 0;   <comment>// count of set bits</comment>
   bits cword = 0;   <comment>// assuming m &lt;= 32 bits</comment>
   srandom(hash(attr_value));
   while (nbits &lt; k) {
      int i = random() % m;
      if (((1 &lt;&lt; i) &amp; cword) == 0) {
         cword |= (1 &lt;&lt; i);
         nbits++;
      }
   }
   return cword;  <comment>// m-bits with k 1-bits and m-k 0-bits</comment>
}
</pre>
<p>
The <tt>findPagesUsingTupSigs()</tt> take a tuple signature
and scans the <i>Rel</i>.tsig file, comparing that signature
to the stored tuple signatures. It builds a bit-string showing
which pages contain at least one "matching" tuple.
It behaves roughly as follows:
</p><pre>QuerySig = makeTupleSig(Query)
Pages = AllZeroBits
foreach Tsig in tsigFile {
    if (Tsig matches QuerySig) {
        PID = data page for tuple corresponding to Tsig
        include PID in Pages
    }
}
</pre>
<p>
Note that the i<sup>th</sup> tuple in the data file
has its correpsonding signature as the i<sup>th</sup>
signature in the <i>Rel</i><tt>.tsig</tt> file.
However, since tuples and tuple signatures are
different sizes, the page that the signature appears
on will not necessarily have the same page ID as the
page in which the corresponding tuple is located.
</p>

<h2>Task 4: Page Signatures
<span style="font-weight:normal; font-size:50%">(5 marks)
</span></h2>
<p>
Implement indexing using page-level signatures (<tt>psigs</tt>).
</p>
This is similar to how tuple-level signature indexing
is done, except that the signatures are larger.
<span style="color:#CC0000">
Also, the number of bits set in each codeword should be reduced
proportionately, so that roughly half the bits are set in each
signature when the page is full. Since the signatures are coming
from <i>c</i> tuples, the bits per codeword value should be divided 
by this value (<i>c</i>).
</span>
The functions that you need to complete are <tt>makePageSig()</tt> and
<tt> findPagesUsingPageSigs()</tt> in the <tt>psig.c</tt>
file. You will also need to add more code to the
<tt>addToRelation()</tt> function to maintain page signatures
when new tuples are inserted.
<p></p>
<p>
One major difference between tuple signatures and page signatures
is that page signatures are not a one-off insertion.
When a new tuple is added, its page-level signature  needs to be
included page signature for the page where it it is inserted.
The process can be described roughly as follows:
</p>
<pre>new Tuple is inserted into page PID
Psig = makePageSig(Tuple)
PPsig = fetch page signature for data page PID from psigFile
merge Psig and PPsig giving a new PPsig
update page signature for data page PID in psigFile
</pre>
<p>
The <tt>makePageSig()</tt> function be used to generate
a page-level signature for the query, and then used to
generate a bit-string of matching pages roughly as follows:
</p>
<pre>QuerySig = makePageSig(Query)
Pages = AllZeroBits
foreach Psig in psigFile {
    if (Psig matches QuerySig) {
        PID = data page corresponding to Psig
        include PID in Pages
    }
}
</pre>

<h2>Task 5: Bit-sliced Signatures
<span style="font-weight:normal; font-size:50%">(7 marks)
</span></h2>
<p>
Implement indexing using bit-sliced page signatures.
</p>
<p>
Each bit-slice is effectively a list of pages that
have a specific bit from the page-signature set to 1
(e.g. if a page-level signature has bit 5 set to one,
then bit-slice 5 has a 1 bit for every page with a
page signature where bit 5 is set).
This drives both the updating of bit-slices and their
use in indexing.
</p>
<p>
You will need to modify the functions:
<tt>newRelation()</tt> in <tt>reln.c</tt>,
<tt>addToRelation()</tt> in <tt>reln.c</tt>,
and
<tt>findPagesUsingBitSlices()</tt> in <tt>bsig.c</tt>.
The modifications to <tt>newRelation()</tt> are
relatively straightforward, but remember to update
the relation parameters appropriately.
</p>
<p>
The <tt>addToRelation()</tt> should take a tuple,
produce a page signature for it, then update all
of the bit-slices corresponding to 1-bits in the
page signature.
This can be described roughly as follows:
</p>
<pre>PID = data page where new Tuple inserted
Psig = makePageSig(Tuple)
for each i in  0..pm-1 {
    if (Psig bit[i] is 1) {
        Slice = get i'th bit slice from bsigFile
        set the PID'th bit in Slice
        write updated Slice back to bsigFile
    }
}
</pre>
<p>
The <tt>findPagesUsingBitSlices()</tt> function
computes a page-level signature for query and
then takes an intersection of the bit-slices
corresponding to the 1-bits in the page signature.
This gives a "matching" pages list straight away,
and hopefully after reading far less of the
<i>Rel</i><tt>.bsig</tt> file than would be read
using a <i>Rel</i><tt>.psig</tt> file.
The method can be described roughly as follows:
</p>
<pre>Qsig = makePageSig(Query)
Pages = AllOneBits
for each i in 0..pm-1 {
    if (Qsig bit[i] is 1) {
        Slice = get i'th bit slice from bsigFile
        zero bits in Pages which are zero in Slice
    }
}
</pre>

<h2 id="testing">Testing</h2>
<p>
The following simple tests provide a sanity-check for your code,
once you've got it sufficiently implemented to execute (at least
partially) the <tt>insert</tt> and <tt>select</tt> commands.
<span class="red">
Note that the sample data used in this example is available
in the file: <a href="https://cgi.cse.unsw.edu.au/~cs9315/21T1/assignments/ass2/R.in">/web/cs9315/21T1/assignments/ass2/R.in</a>
</span>
</p>
<pre><span class="comment"># make a file to hold 10000 6-attribute tuples</span>
$ <b>./create R simc 10000 6 1000</b>
<span class="comment"># make some data, and save it in a file</span>
$ <b>./gendata 10000 6 1234567 13 &gt; R.in</b>
<span class="comment"># load tuples from R.in into files of relation R</span>
$ <b>./insert R &lt; R.in</b>
<span class="comment"># check the structure of R's files</span>
$ <b>./stats R</b>
Global Info:
Dynamic:
  #items:  tuples: 10000  tsigs: 10000  psigs: 137  bsigs: 6304
  #pages:  tuples: 137  tsigs: 27  psigs: 28  bsigs: 28
Static:
  tups   #attrs: 6  size: 56 bytes  max/page: 73
  sigs   bits/attr: 9
  tsigs  size: 88 bits (11 bytes)  max/page: 372
  psigs  size: 6304 bits (788 bytes)  max/page: 5
  bsigs  size: 144 bits (18 bytes)  max/page: 227
<span class="comment"># linear scan of all data (i.e. run an open query; ignore signatures)</span>
<span class="comment"># if you want to see alll 10000 tuples, don't pipe through tail</span>
$ <b>./select R '?,?,?,?,?,?' x | tail -6</b>
<span class="comment"># search for a tuple by the first attribute (not using signatures)</span>
$ <b>./select R '1234999,?,?,?,?,?' x</b>
1234999,UEkVEljYuGrloQCzLjmw,a3-183,a4-100,a5-017,a6-432
Query Stats:
# sig pages read:    0
# signatures read:   0
# data pages read:   137
# tuples examined:   10000
# false match pages: 136
<span class="comment"># search for a tuple by the first attribute (using tuple signatures)</span>
$ <b>./select R '1234999,?,?,?,?,?' t</b>
1234999,UEkVEljYuGrloQCzLjmw,a3-183,a4-100,a5-017,a6-432
Query Stats:
# sig pages read:    27
# signatures read:   10000
# data pages read:   5
# tuples examined:   365
# false match pages: 4
<span class="comment"># search for a tuple by first attribute (using page signatures)</span>
$ <b>./select R '1234999,?,?,?,?,?' p</b>
1234999,UEkVEljYuGrloQCzLjmw,a3-183,a4-100,a5-017,a6-432
Query Stats:
# sig pages read:    28
# signatures read:   137
# data pages read:   1
# tuples examined:   73
# false match pages: 0
<span class="comment"># search for a tuple by first attribute (using bit-sliced signatures)</span>
$ <b>./select R '1234999,?,?,?,?,?' b</b>
1234999,UEkVEljYuGrloQCzLjmw,a3-183,a4-100,a5-017,a6-432
Query Stats:
# sig pages read:    7
# signatures read:   9
# data pages read:   1
# tuples examined:   73
# false match pages: 0
<span class="comment"># check for expeected answers</span>
$ <b>grep 'a3-241,a4-158,a5-407' R.in</b>
1237049,ovnsbtUWihCcCEoRWKcF,a3-241,a4-158,a5-407,a6-490
1242029,eptevNjxFwayfSGeFKrO,a3-241,a4-158,a5-407,a6-490
<span class="comment"># search for tuples via several attributes (using no signatures)</span>
$ <b>./select R '?,?,a3-241,a4-158,a5-407,?' x</b>
1237049,ovnsbtUWihCcCEoRWKcF,a3-241,a4-158,a5-407,a6-490
1242029,eptevNjxFwayfSGeFKrO,a3-241,a4-158,a5-407,a6-490
Query Stats:
# sig pages read:    0
# signatures read:   0
# data pages read:   137
# tuples examined:   10000
# false match pages: 135
<span class="comment"># search for tuples via several attributes (using tuple signatures)</span>
$ <b>./select R '?,?,a3-241,a4-158,a5-407,?' t</b>
1237049,ovnsbtUWihCcCEoRWKcF,a3-241,a4-158,a5-407,a6-490
1242029,eptevNjxFwayfSGeFKrO,a3-241,a4-158,a5-407,a6-490
Query Stats:
# sig pages read:    27
# signatures read:   10000
# data pages read:   2
# tuples examined:   146
# false match pages: 0
<span class="comment"># search for tuples via several attributes (using page signatures)</span>
$ <b>./select R '?,?,a3-241,a4-158,a5-407,?' p</b>
1237049,ovnsbtUWihCcCEoRWKcF,a3-241,a4-158,a5-407,a6-490
1242029,eptevNjxFwayfSGeFKrO,a3-241,a4-158,a5-407,a6-490
Query Stats:
# sig pages read:    28
# signatures read:   137
# data pages read:   2
# tuples examined:   146
# false match pages: 0
<span class="comment"># search for tuples via several attributes (using bit-sliced signatures)</span>
$ <b>./select R '?,?,a3-241,a4-158,a5-407,?' b</b>
1237049,ovnsbtUWihCcCEoRWKcF,a3-241,a4-158,a5-407,a6-490
1242029,eptevNjxFwayfSGeFKrO,a3-241,a4-158,a5-407,a6-490
Query Stats:
# sig pages read:    17
# signatures read:   27
# data pages read:   2
# tuples examined:   146
# false match pages: 0
<span class="comment"># etc etc etc etc etc (think of more tests)</span>
</pre>
<p>
Based on the above, you should be able to devise other tests to check
whether your <tt>select</tt> is producing the correct answers, and
whether it's producing the same number of signature reads and
signature page reads.
If it reads extra data pages using the same false match probability,
that's not catastrophic; however, reading more data pages is
sub-optimal and will be penalised.
With different false match probabilities and the same data, you would
expect different numbers of pages to be read.
</p>
<p>
If you want to calculate the overall costs of the above methods,
you should consider the sum of the page reads (both signature and
data pages).
The best method is one that minimises this cost (e.g. read less
signature pages, but read no more data pages).
You can tune the search methods by changing the false match probability;
a higher false match probability produces smaller signatures, but results
in more false-match pages being read.
</p><p>
Make sure you test your code on the CSE servers before you submit.
It might work on your laptop, but there might be portability issues
in moving it to the CSE servers.
We test your code on the CSE servers; if it doesn't work there, it
doesn't work as far as we're concerned.
</p>

<h2 id="submission">Submission</h2>
<p>
You need to submit a single <tt>tar</tt> file containing all of
the code files that are needed to build the <tt>create</tt>,
<tt>insert</tt>, <tt>select</tt> and <tt>stats</tt> commands,
including a new <tt>Makefile</tt> if you add extra modules.
</p>
<p>
You should not submit the code for the commands, i.e. do not
submit <tt>create.c</tt>, <tt>insert.c</tt>, <tt>select.c</tt>,
<tt>stats.c</tt> and <tt>dump.c</tt>.
Also, do not submit the code for the testing programs
(<tt>x1.c</tt>, <tt>x2.c</tt>, <tt>x3.c</tt>) or the hash function
(<tt>hash.h</tt> and <tt>hash.c</tt>).
We will provide the original versions of all of these for testing your code.
And a reminder: all of the commands will use the module interfaces
defined in the <tt>*.h</tt> files; do not change these interfaces.
You may, however, add as many private functions as you like into the
submitted files.
</p>
<p>
When you want to submit your work, do the following:
</p>
<pre>$ <b>cd <i>your/ass2/directory</i></b>
$ <b>tar cf ass2.tar <i>FilesToSubmit</i></b>
</pre>
<p>
The <tt><i>FilesToSubmit</i></tt> would typically include:
</p>
<pre>bits.c bsig.c page.c psig.c query.c reln.c tsig.c util.c
</pre>
<p>
plus any other modules you may have created, along with the
modified <tt>Makefile</tt> to include them in the compilation.
If you change any <tt>*.h</tt> files, (a) they must provide at
least the original interface, (b) you must include them in your
submission.
</p>
<p>
Once you have generated the <tt>ass2.tar</tt> file, you can submit
it via WebCMS, or by using <tt>give</tt>.
</p>
<p>
<b>Be careful</b> to include all of the files needed to make
your system work. If you omit a file and we need to get it from
you later, you will be penalised 1 mark for this assignment.
Similarly, if you submit code that doesn't compile, and we need
to fix it, you will be penalised 1 mark for this assignment.
</p>

<h2 id="changelog">ChangeLog</h2>
<ul>
            <li>
            <strong>v1.0</strong>
            (2021-03-19 16:00:00+10:00)<br>
            <ul>
                                    <li>released Assignment 2</li>
                            </ul>
        </li>
            <li>
            <strong>v1.1</strong>
            (2021-04-02 20:00:00+10:00)<br>
            <ul>
                                    <li>Added clarification for Task 3 to make it obvious that both SIMC and CATC must be implemented.</li>
                                    <li>Added algorithm for computing codewords (wasn't in the lecture notes as promised).</li>
                                    <li>Added comment on number of bits set to 1 in page-level codewords.</li>
                            </ul>
        </li>
            <li>
            <strong>v1.2</strong>
            (2021-04-12 08:00:00+10:00)<br>
            <ul>
                                    <li>added sample R.in file to assignment directory</li>
                            </ul>
        </li>
    </ul>

<p>Have fun, <i>jas</i></p>


</body></html>